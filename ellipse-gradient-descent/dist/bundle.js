/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/optimization-js/src/optimization.js":
/*!**********************************************************!*\
  !*** ./node_modules/optimization-js/src/optimization.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Dimension of real type.\n * @constructor\n * @param {Number} low Lower bound of the values. Lower bound is inclusive.\n * @param {Number} high Upper inclusive bound of the values of dimension.\n */\nfunction Real(low, high){\n    this.low = low\n    this.high = high\n\n    /**\n     * Generate random uniformly distributed scalar sample from dimension space.\n     * @returns {Number} Sample value.\n     */\n    this.random_sample = function(){\n        /* Returns a uniformly sampled value from the space */\n        return Math.random()*(this.high - this.low) + this.low\n    }\n}\nmodule.exports.Real = function(low, high){\n    return new Real(low, high);\n}\n\n/**\n * Dimension of integer type.\n * @constructor\n * @param {Integer} low Lower bound of the values. Lower bound is inclusive.\n * @param {Integer} high Upper inclusive bound of the values of dimension.\n */\nfunction Integer(low, high){\n    this.low = low\n    this.high = high\n\n    /**\n     * Generate random uniformly distributed integer sample from dimension space.\n     * @returns {Number} Sample value.\n     */\n    this.random_sample = function(){\n        /* Returns a uniformly sampled value from the space */\n        var result = Math.random()*(this.high - this.low) + this.low\n        return Math.round(result)\n    }\n}\nmodule.exports.Integer = function(low, high){\n    return new Integer(low, high)\n}\n\n/**\n * Dimension of categorical type. Values of the dimension can be a mix of integer,\n * float, string and boolean values (tested) as well as it is expected that other\n * javascript types should work.\n * @constructor\n * @param {Array} categories A set of all feasible values for the dimension. For\n * example, it could be ['a', 1, 2.0, 'zazz', true].\n */\nfunction Categorical(categories){\n    this.categories = categories\n\n    /**\n     * Generate random uniformly distributed integer sample from dimension space.\n     * @returns {Number} Sample value.\n     */\n    this.random_sample = function(){\n        /* Returns a uniformly sampled value from the array of categorical values */\n        var N = this.categories.length\n        // index of value to be returned\n        var index = Math.round(Math.random()*(N-1))\n        return this.categories[index]\n    }\n}\nmodule.exports.Categorical = function(categories){\n    return new Categorical(categories)\n}\n\n/**\n * An object that represents a search space for an optimization problem.\n * Contains some helper methods, such as methods for automated sampling\n * of values from the space.\n * @constructor\n * @param {Number} dimensions An array of dimension descriptors that are\n * used to specify search space.\n */\nfunction Space(dimensions){\n    /*Stores a set of dimensions and provides convenience funcs */\n    this.dimensions = dimensions;\n\n    /**\n     * Sample n points from the search space at random. Sampling is done\n     * using functionality provided by the dimension classes themselves.\n     * @param {Integer} n Number of points to sample.\n     * @returns {Arrray} An array of vectors containing sampled values.\n     */\n    this.rsv = function(n){\n        /*Sample n points from space at random.*/\n        var X = []\n        for(var i = 0; i < n; i++){\n            var x = []\n            for(var dim of this.dimensions){\n                x.push(dim.random_sample())\n            }\n            X.push(x)\n        }\n        return X\n    }\n}\nmodule.exports.Space = function(dimensions){\n    return new Space(dimensions)\n}\n\n/**\n * A convenience function for conversion of Array of dimensions into a\n * single {@link Space} instance.\n * @param {Object} space_object Either an array of dimension objects, or\n * a {@link Space} instance.\n * @returns {Space} an instance of {@link Space} created out of the provided\n * objects.\n */\nmodule.exports.to_space = function(space_object){\n    // check if list of dimensions\n    if(space_object instanceof Array){\n        return module.exports.Space(space_object)\n    }\n\n    if(space_object instanceof Space){\n        return space_object\n    }\n\n    throw 'Unknown space definition'\n}\n\n/**\n * A random optimization function. Sometimes competitive in practice\n * for hyperparameter tuning for instance.\n * @constructor\n * @param {Object} space An array of dimension descriptors that are\n * used to specify search space or an instance of {@link Space}.\n * @property {Array} X An array of arguments tried.\n * @property {Array} Y An array of function values observed. The\n * order corresponds to the order in arguments array.\n * @property {Array} best_x An argument that results in minimal objective\n * function value.\n * @property {Number} best_y Minimal objective value observed.\n * @property {Space} space Optimization space over which the optimization is done.\n */\nfunction RandomOptimizer(space){\n    this.space = module.exports.to_space(space)\n    this.X = []\n    this.Y = []\n    this.best_x = null\n    this.best_y = null\n\n    /**\n     * Get the next point or array of points to evaluate.\n     * @param {Number} n Specifies how many points should be provided by\n     * the optimizer algorithm to try in parallel. If specified, an array\n     * of points to evaluate is returned. If not, only a single point is\n     * returned verbatium.\n     */\n    this.ask = function(n=null){\n        if(n == null){\n            return this.space.rsv(1)[0]\n        }\n\n        // return array of points\n        return this.space.rsv(n)\n    }\n\n    /**\n     * Report back to the optimizer the points that were tried. Do not\n     * really need to do it for random sampling, but this is here for\n     * consistency with future more \"intelligent\" algorithms.\n     * @param {Array} X Array of observed points.\n     * @param {Array} Y Array of objective values corresponding to the\n     * points that were evaluated.\n     */\n    this.tell = function(X, Y){\n        for(var i = 0; i < X.length; i++){\n            if(this.best_y == null || Y[i] < this.best_y){\n                this.best_y = Y[i]\n                this.best_x = X[i]\n            }\n        }\n\n        // record observations\n        this.X = this.X.concat(X)\n        this.Y = this.Y.concat(Y)\n\n    }\n\n}\n\nmodule.exports.RandomOptimizer = function(space){\n    return new RandomOptimizer(space)\n}\n\n/**\n * Only Mutation Genetic Optimizer;\n * A class that performs optimization via random permutations to the best\n * found point thus far. Such approach in particular yields better results\n * than with crossover on the SigOpt's \"evalset\" set of problems.\n * @constructor\n * @param {Array} dimensions A list of dimensions or a {@link Space} object.\n * Describes the space of values over which a function will be optimized.\n * @param {Integer} n_random_starts Determines how many points wil be generated\n * initially at random. The points are not generated at random after this\n * number of evaluations has been reported to the optimizer.\n * @param {Number} mutation_rate A value in the range of (0.0, 1.0]\n * @property {Array} X An array of arguments tried.\n * @property {Array} Y An array of function values observed. The\n * order corresponds to the order in arguments array.\n * @property {Array} best_x An argument that results in minimal objective\n * function value.\n * @property {Number} best_y Minimal objective value observed.\n * @property {Space} space Optimization space over which the optimization is done.\n */\nfunction OMGOptimizer(dimensions, n_random_starts = 13, mutation_rate = 0.1) {\n\n    this.space = module.exports.to_space(dimensions);\n    this.n_random_starts = n_random_starts;\n    this.mutation_rate = mutation_rate;\n    this.n_random_starts_ = n_random_starts;\n    this.X = []\n    this.Y = []\n    this.best_x = null\n    this.best_y = null\n\n    /**\n    * Generates a boolean value at random. Is used for random mutations.\n    * @param {Number} p Probability of generation of true value\n    * @returns {Boolean} a randomly generated boolean value.\n    */\n    this.rnd = function (p = null) {\n\n        // by default use mutation rate as probability\n        if (p == null) {\n            p = this.mutation_rate;\n        }\n\n        if (Math.random() < p) {\n            return true;\n        }\n\n        return false\n\n    } // end rnd\n\n    /**\n    * Generates the next point to evaluate. Different points will be generated for multiple calls, which can be used for parallelisation of optimization.\n    * @returns {Array} a point to evaluate.\n    */\n    this.ask = function () {\n\n        // the usual initialization with random sampling from search space\n        if (this.n_random_starts_ > 0) {\n            return this.space.rsv(1)[0];\n        } // end random\n\n        finished = false;\n\n        while (!finished) {\n            // loop necessary to ensure that mutated value is generated\n\n            var result = []\n\n            var best_x = this.X[0]\n            var best_y = this.Y[0]\n\n            for (var i = 1; i < this.Y.length; i++) {\n                if (this.Y[i] < best_y) {\n                    best_x = this.X[i]\n                    best_y = this.Y[i]\n                }\n            }\n\n            for (var i = 0; i < this.space.dimensions.length; i++) {\n                var v = best_x[i];\n                var dim = this.space.dimensions[i];\n\n                if (dim instanceof Categorical && this.rnd()) {\n                    // select a new category here at random\n                    var sell = Math.round(Math.random() * (dim.categories.length - 1))\n\n                    v = dim.categories[sell]\n                    finished = true;\n\n                } // end handling categorical\n\n                if ((dim instanceof Real || (dim instanceof Integer)) && this.rnd()) {\n\n                    var low = dim.low;\n                    var high = dim.high;\n\n                    for (var pw = -16; pw <= 1; pw++) {\n\n                        if (this.rnd()) {\n                            finished = true;\n\n                            if (this.rnd(0.5)) { // determine the sign here\n                                diff = high - v\n                            } else {\n                                diff = low - v\n                            }\n\n                            v = v + diff * Math.pow(2, pw)\n\n                        } // end exp change\n\n                    }  // end handling the exponential change\n\n                    // clamp the dimension\n                    if (v < low) {\n                        v = low;\n                    }\n\n                    if (v > high) {\n                        v = high;\n                    }\n\n                    // round the dimension if it is integer\n                    if (dim instanceof Integer) {\n                        v = Math.round(v);\n                    }\n\n                } // end handling of the ordered type dimensions\n\n                result.push(v);\n\n            } // end dimension enumeration\n\n        } // end while loop of sampling\n\n        return result;\n\n    } // end of ask function\n\n    /**\n    *Function for reporting of the observed function values\n    * @param {Array} X Array of observed points.\n    * @param {Array} Y Array of objective values corresponding to the\n    * points that were evaluated.\n    */\n    this.tell = function (X, Y) {\n\n        for(var i = 0; i < X.length; i++){\n            this.n_random_starts_ -= 1\n\n            if(this.best_y == null || Y[i] < this.best_y){\n                this.best_y = Y[i]\n                this.best_x = X[i]\n            }\n        }\n\n        if(this.n_random_starts_ < 0){\n            this.n_random_starts_ = 0\n        }\n\n        // record observations\n        this.X = this.X.concat(X)\n        this.Y = this.Y.concat(Y)\n\n    } // end of tell function\n\n} // end of optimizer class\n\nmodule.exports.OMGOptimizer = function(dimensions, n_random_starts = 13, mutation_rate = 0.1){\n    return new OMGOptimizer(dimensions, n_random_starts, mutation_rate)\n}\n\n/**\n * Minimize a function using a random algorithm.\n * While naive, such approach is often surprisingly competitive\n * for hyperparameter tuning purposes. Internally uses {@link RandomOptimizer}\n * class to perform optimization.\n * @param {function} fnc Function to be minimized.\n * @param {Array} dimensions An array of dimensions, that describe a search space for minimization,\n * or an instance of {@link Space} object.\n * @param {Number} [n_calls=64] Function evaluation budget. The function will be evaluated for\n * at most this number of times.\n * @return {RandomOptimizer} The optimizer instance, that contains information about found minimum and explored arguments.\n*/\nfunction dummy_minimize (func, dimensions, n_calls=64){\n    var opt = module.exports.RandomOptimizer(dimensions);\n\n    for(var iter=0; iter < n_calls; iter++){\n        var x = opt.ask()\n        var y = func(x)\n        opt.tell([x], [y])\n    }\n\n    return opt\n}\nmodule.exports.dummy_minimize = dummy_minimize\n\n/**\n * Minimize a function using a random algorithm.\n * While naive, such approach is often surprisingly competitive\n * for hyperparameter tuning purposes. Internally uses {@link RandomOptimizer}\n * class to perform optimization.\n * @param {function} fnc Function to be minimized.\n * @param {Array} dimensions An array of dimensions, that describe a search space for minimization,\n * or an instance of {@link Space} object.\n * @param {Number} [n_calls=64] Function evaluation budget. The function will be evaluated for\n * at most this number of times.\n * @param {Integer} n_random_starts Determines how many points wil be generated\n * initially at random. The points are not generated at random after this\n * number of evaluations has been reported to the optimizer.\n * @param {Number} mutation_rate A value in the range of (0.0, 1.0]\n * @return {OMGOptimizer} The optimizer instance, that contains information about found minimum and explored arguments.\n*/\nfunction rs_minimize (func, dimensions, n_calls=64, n_random_starts=13, mutation_rate=0.1){\n    var opt = module.exports.OMGOptimizer(\n        dimensions,\n        n_random_starts,\n        mutation_rate\n    );\n\n    for(var iter=0; iter < n_calls; iter++){\n        var x = opt.ask()\n        var y = func(x)\n        opt.tell([x], [y])\n    }\n\n    return opt\n}\nmodule.exports.rs_minimize = rs_minimize\n\n/**\n * Minimize an unconstrained function using zero order Powell algorithm.\n * @param {function} fnc Function to be minimized. This function takes\n * array of size N as an input, and returns a scalar value as output,\n * which is to be minimized.\n * @param {Array} x0 An array of values of size N, which is an initialization\n *  to the minimization algorithm.\n * @return {Object} An object instance with two fields: argument, which\n * denotes the best argument found thus far, and fncvalue, which is a\n * value of the function at the best found argument.\n*/\nmodule.exports.minimize_Powell = function (fnc, x0) {\n    var eps = 1e-2;\n\n    var convergence = false;\n    var x = x0.slice(); // make copy of initialization\n    var alpha = 0.001; // scaling factor\n\n    var pfx = Math.exp(10);\n    var fx = fnc(x);\n    var pidx = 1;\n    while (!convergence) {\n\n        var indicies = shuffleIndiciesOf(x);\n        convergence = true;\n\n        // Perform update over all of the variables in random order\n        for (var i = 0; i < indicies.length; i++) {\n\n            x[indicies[i]] += 1e-6;\n            var fxi = fnc(x);\n            x[indicies[i]] -= 1e-6;\n            var dx = (fxi - fx) / 1e-6;\n\n            if (Math.abs(dx) > eps) {\n                convergence = false;\n            }\n\n            x[indicies[i]] = x[indicies[i]] - alpha * dx;\n            fx = fnc(x);\n\n        }\n\n        // a simple step size selection rule. Near x function acts linear\n        // (this is assumed at least) and thus very small values of alpha\n        // should lead to (small) improvement. Increasing alpha would\n        // yield better improvement up to certain alpha size.\n\n        alpha = pfx > fx ? alpha * 1.1 : alpha * 0.7;\n        pfx = fx;\n\n        pidx--;\n        if (pidx === 0) {\n            pidx = 1;\n        }\n\n    }\n\n    var solution = {};\n    solution.argument = x;\n    solution.fncvalue = fx;\n\n    return solution;\n\n};\n\n/**\n * Minimize an unconstrained function using first order gradient descent algorithm.\n * @param {function} fnc Function to be minimized. This function takes\n * array of size N as an input, and returns a scalar value as output,\n * which is to be minimized.\n * @param {function} grd A gradient function of the objective.\n * @param {Array} x0 An array of values of size N, which is an initialization\n *  to the minimization algorithm.\n * @return {Object} An object instance with two fields: argument, which\n * denotes the best argument found thus far, and fncvalue, which is a\n * value of the function at the best found argument.\n*/\nmodule.exports.minimize_GradientDescent = function (fnc, grd, x0) {\n    // fnc: function which takes array of size N as an input\n    // grd: gradient (array of size N) of function for some input\n    // x0: array or real numbers of size N;\n    // serves as initialization of algorithm.\n\n    // solution is a struct, with fields:\n    // argument: solution argument\n    // fncvalue: function value at found optimum\n    var x = x0.slice();\n\n    var convergence = false;\n    var eps = 1e-3;\n    var alpha = 0.01;\n\n    var pfx = fnc(x);\n\n    var numIterations = 0;\n    var maxIterations = 1000;\n    while (!convergence && numIterations < maxIterations) {\n        numIterations += 1;\n        var g = grd(x);\n        convergence = vect_max_abs_x_less_eps(g, eps);\n\n        if (convergence) {\n            break;\n        }\n\n        var repeat = true;\n\n        // a simple step size selection rule. Near x function acts linear\n        // (this is assumed at least) and thus very small values of alpha\n        // should lead to (small) improvement. Increasing alpha would\n        // yield better improvement up to certain alpha size.\n\n        while (repeat) {\n            var xn = x.slice();\n            vect_x_pluseq_ag(xn, -alpha, g); // perform step\n            var fx = fnc(xn);\n\n            repeat = pfx < fx;\n            // this automatically selects step size\n            alpha = repeat ? alpha * 0.7 : alpha * 1.1;\n        }\n\n        x = xn;\n        pfx = fx;\n\n    }\n\n    var solution = {};\n    solution.argument = x;\n    solution.fncvalue = fx;\n    return solution;\n\n};\n\n/**\n * Minimize an unconstrained function using first order L-BFGS algorithm.\n * @param {function} fnc Function to be minimized. This function takes\n * array of size N as an input, and returns a scalar value as output,\n * which is to be minimized.\n * @param {function} grd A gradient function of the objective.\n * @param {Array} x0 An array of values of size N, which is an initialization\n *  to the minimization algorithm.\n * @return {Object} An object instance with two fields: argument, which\n * denotes the best argument found thus far, and fncvalue, which is a\n * value of the function at the best found argument.\n*/\nmodule.exports.minimize_L_BFGS = function (fnc, grd, x0) {\n    // fnc: function which takes array of size N as an input\n    // grd: gradient (array of size N) of function for some input\n    // x0: array or real numbers of size N;\n    // serves as initialization of algorithm.\n\n    // solution is a struct, with fields:\n    // argument: solution argument\n    // fncvalue: function value at found optimum\n    var x = x0.slice();\n\n    var eps = 1e-5; // max abs value of gradient component for termination\n    var alpha = 0.001; // initial step size\n    var m = 5; // history size to keep for Hessian approximation\n\n    var pfx = fnc(x);\n    var s = []; // this is needed for lbfgs procedure\n    var y = [];\n    var ro = [];\n\n    var g = grd(x);\n    var direction = g.slice();\n    var convergence = false;\n    while (!convergence) {\n\n        var xn = x.slice();\n        vect_x_pluseq_ag(xn, alpha, direction); // perform step\n        var fx = fnc(xn);\n        alpha = pfx < fx ? alpha * 0.5 : alpha * 1.2; // magic!\n\n        //  < ================= apply limited memory BFGS procedure ================= >\n        var gn = grd(xn);\n\n        if (vect_max_abs_x_less_eps(gn, eps)) {\n            break;\n        }\n\n        var dx = vect_a_minus_b(xn, x);\n        var dg = vect_a_minus_b(gn, g);\n\n        s.unshift(dx);\n        y.unshift(dg);\n        var tmp = 1 / (dot(dx, dg));\n        ro.unshift(tmp);\n\n        if (s.length > m) {\n            s.pop();\n            y.pop();\n            ro.pop();\n        }\n\n        var r = g.slice();\n        var a = new Array(s.length);\n\n        for (var i = 0; i < s.length; i++) {\n            var pi = 1 / (dot(s[i], y[i]));\n            a[i] = pi * dot(s[i], r);\n            vect_x_pluseq_ag(r, -a[i], y[i]);\n        }\n\n        // perform Hessian scaling\n        var scale = dot(dx, dg) / dot(dg, dg);\n        for (var i = 0; i < r.length; i++) {\n            r[i] = r[i] * scale;\n        }\n\n        for (var i = 0; i < s.length; i++) {\n            var j = s.length - i - 1;\n            var pj = 1 / (dot(s[j], y[j]));\n            var beta = pj * dot(y[j], r);\n            vect_x_pluseq_ag(r, (a[j] - beta), s[j]);\n        }\n        direction = r.slice();\n\n        //  < ================= apply limited memory BFGS procedure ================= >\n\n        for (var i = 0; i < direction.length; i++) {\n            direction[i] = -direction[i];\n        }\n\n        pfx = fx;\n        x = xn;\n        g = gn;\n\n    }\n\n    var solution = {};\n    solution.argument = x;\n    solution.fncvalue = fx;\n    return solution;\n\n};\n\n/*module.exports.numerical_gradient = function (fnc, x) {\n    // can be used as for gradient check or its substitute. Gradient is approx. via forward difference\n    var grad = x.slice();\n    var fx = fnc(x);\n    var h = 1e-6; // step size\n\n    for (var i = 0; i < x.length; i++) {\n\n        // approximation using simple forward difference\n        x[i] += h;\n        var fxi = fnc(x);\n        x[i] -= h;\n\n        grad[i] = (fxi - fx) / h;\n    }\n    return grad;\n};*/\n\n/**\n * Shuffles indicies of arrray.\n * @ignore\n * @param {Array} array Array to shuffle.\n */\nfunction shuffleIndiciesOf (array) {\n    var idx = [];\n    for (var i = 0; i < array.length; i++) {\n        idx.push(i);\n    }\n    for (var i = 0; i < array.length; i++) {\n        var j = Math.floor(Math.random() * i);\n        var tmp = idx[i];\n        idx[i] = idx[j];\n        idx[j] = tmp;\n    }\n    return idx;\n};\n\n/**\n * Computes dot product.\n * @ignore\n * @param {Array} a First vector argument.\n * @param {Array} b Second vector argument.\n */\nfunction dot (a, b) {\n    var result = 0;\n    for (var i = 0; i < a.length; i++) {\n        result += a[i] * b[i];\n    }\n    return result;\n\n};\n\n/**\n * Substracts vectors.\n * @ignore\n * @param {Array} a First vector argument.\n * @param {Array} b Second vector argument.\n */\nfunction vect_a_minus_b (a, b) {\n    var result = new Array(a.length);\n    for (var i = 0; i < a.length; i++) {\n        result[i] = a[i] - b[i];\n    }\n    return result;\n\n};\n\n/**\n * Fixed step size updating value of x.\n * @ignore\n * @param {Array} x First vector argument.\n * @param {Number} a Step size.\n * @param {Array} g Gradient.\n */\nfunction vect_x_pluseq_ag (x, a, g) {\n    for (var i = 0; i < x.length; i++) {\n        x[i] = x[i] + a * g[i];\n    }\n\n    return x;\n\n};\n\n/**\n * Checks whether absolute values in a vector are greater than\n * some threshold.\n * @ignore\n * @param {Array} x Vector that is checked.\n * @param {Number} eps Threshold.\n */\nfunction vect_max_abs_x_less_eps (x, eps) {\n    // this procedure is used for stopping criterion check\n    for (var i = 0; i < x.length; i++) {\n        if (Math.abs(x[i]) >= eps) {\n            return false;\n        }\n    }\n    return true;\n};\n\n\n//# sourceURL=webpack:///./node_modules/optimization-js/src/optimization.js?");

/***/ }),

/***/ "./src/ComputationalGraph.js":
/*!***********************************!*\
  !*** ./src/ComputationalGraph.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n// name of a variable in the local (node) context\nclass BaseNode {\n\n  constructor(inputRefs, outputRefs) {\n    this.inputRefs = inputRefs;\n    this.outputRefs = outputRefs;\n  }\n}\n\n// Computational graphs are specified by two data structures:\n// - a cache, which records all of the data that the graph needs and computes\n// - a list of nodes, each of which reference input and output data in the cache\n//\n// Splitting the graph into these two structures makes it possible to describe\n// relationships between nodes, like when one node computes something that\n// another node depends on. Data references also make it possible to force\n// two different nodes to share the same parameter.\n//\n// Each node describes how to compute its outputs from its inputs, as well as\n// how to compute the derivative of its output with respect to (wrt) each\n// input (also known as a jacobian). These functions can then be used to\n// implement forward and backward propagation, which could be used for\n// gradient descent.\n\n// name of a variable in the global context\n\n\nfunction getFromCache(cache, refs) {\n  const input = {};\n  for (const key of Object.keys(refs)) {\n    const value = cache.get(refs[key]);\n    if (value == null) {\n      return null;\n    }\n    input[key] = value;\n  }\n  return input;\n}\n\nfunction setToCache(cache, refs, values) {\n  Object.keys(refs).forEach(key => {\n    cache.set(refs[key], values[key]);\n  });\n}\n\n// sort nodes topologically\n// if node A computes something that node B depends on,\n// then A will come before B in the list\nfunction sort(cache, nodes) {\n  let progress = true;\n  const sortedNodes = [];\n  while (progress) {\n    progress = false;\n    for (const node of nodes) {\n      const output = getFromCache(cache, node.outputRefs);\n      if (output != null) {\n        // already been computed\n        continue;\n      }\n      const input = getFromCache(cache, node.inputRefs);\n      if (input == null) {\n        // dependencies are not yet available\n        continue;\n      }\n      setToCache(cache, node.outputRefs, node.forward(input));\n      sortedNodes.push(node);\n      progress = true;\n    }\n  }\n  if (sortedNodes.length !== nodes.length) {\n    throw new Error('failed to sort all nodes');\n  }\n  return sortedNodes;\n}\n\n// given initial data, compute all other values in the graph\n// assumes nodes are topologically sorted\nfunction forward(cache, nodes) {\n  for (const node of nodes) {\n    const input = getFromCache(cache, node.inputRefs);\n    if (input == null) {\n      throw new Error('the cache is missing some references! either the nodes are not ' + 'sorted, or the cache was not initialized correctly');\n    }\n    setToCache(cache, node.outputRefs, node.forward(input));\n  }\n}\n\n// given a ref, compute the derivative of it wrt all other refs\n// assumes nodes are topologically sorted\nfunction backward(cache, nodes, root) {\n  // first do a forward pass to fill out the values\n  forward(cache, nodes);\n\n  // reverse the nodes in order to propagate backwards\n  const nodesRev = [...nodes].reverse();\n\n  const derivatives = new Map();\n\n  // initialize all other derivatives to zero to start with\n  for (const [key] of cache) {\n    derivatives.set(key, 0);\n  }\n\n  // derivative of the root wrt itself is just 1\n  derivatives.set(root, 1);\n\n  for (const node of nodesRev) {\n    const rootWrtOutputs = getFromCache(derivatives, node.outputRefs);\n    if (rootWrtOutputs == null) {\n      throw new Error('initial derivatives were not initialized');\n    }\n\n    const input = getFromCache(cache, node.inputRefs);\n    const output = getFromCache(cache, node.outputRefs);\n    if (input == null || output == null) {\n      throw new Error('forward pass was incomplete');\n    }\n\n    // get the derivatives of inputs computed by other nodes\n    // (should be zeros if no other nodes have computed them yet)\n    const rootWrtInputs = getFromCache(derivatives, node.inputRefs);\n    if (rootWrtInputs == null) {\n      throw new Error('initial derivatives were not initialized');\n    }\n\n    // compute the local gradient of outputs wrt inputs\n    const jacobian = node.backward(input, output);\n\n    // compute the derivative of the root wrt to each input\n    Object.keys(node.inputRefs).forEach(inputKey => {\n      const inputRef = node.inputRefs[inputKey];\n      const outputsWrtInputs = jacobian[inputKey];\n\n      // sum over the derivative of each output\n      const rootWrtInput = Object.keys(node.outputRefs).reduce((value, outputKey) => value + rootWrtOutputs[outputKey] * outputsWrtInputs[outputKey], rootWrtInputs[inputKey]);\n\n      // add to gradient computed by other nodes\n      derivatives.set(inputRef, rootWrtInput);\n    });\n  }\n\n  return derivatives;\n}\n\nmodule.exports = {\n  BaseNode,\n  sort,\n  forward,\n  backward\n};\n\n//# sourceURL=webpack:///./src/ComputationalGraph.js?");

/***/ }),

/***/ "./src/EllipseNodes.js":
/*!*****************************!*\
  !*** ./src/EllipseNodes.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\nconst { BaseNode } = __webpack_require__(/*! ./ComputationalGraph */ \"./src/ComputationalGraph.js\");\n\nconst { sqrt, cos, sin } = Math;\n\nclass EllipseNode extends BaseNode {\n  forward({ a, b, x0, y0, theta, phase }) {\n    return { x1: x0 + a * cos(theta + phase), y1: y0 + b * sin(theta + phase) };\n  }\n\n  backward({ a, b, x0, y0, theta, phase }, { x1, y2 }) {\n    return {\n      a: { x1: cos(theta + phase), y1: 0 },\n      b: { x1: 0, y1: sin(theta + phase) },\n      x0: { x1: 1, y1: 0 },\n      y0: { x1: 0, y1: 1 },\n      theta: { x1: -a * sin(theta + phase), y1: b * cos(theta + phase) },\n      phase: { x1: -a * sin(theta + phase), y1: b * cos(theta + phase) }\n    };\n  }\n}\n\nclass ErrorPathNode extends BaseNode {\n\n  constructor(inputRefs, outputRefs, desiredPath) {\n    super(inputRefs, outputRefs);\n    this.desiredPath = desiredPath;\n  }\n\n  _getDesiredPoint(theta) {\n    let wrappedTheta = theta;\n    if (theta < 0) {\n      wrappedTheta += Math.floor(wrappedTheta / (2 * Math.PI)) * -2 * Math.PI;\n    }\n    if (theta > 2 * Math.PI) {\n      wrappedTheta %= 2 * Math.PI;\n    }\n    let index = Math.floor(wrappedTheta / (2 * Math.PI) * this.desiredPath.length);\n    if (index === this.desiredPath.length) {\n      // assume the desired path is a loop\n      index = 0;\n    }\n    if (index < 0 || index >= this.desiredPath.length) {\n      throw new Error(`index out of bounds: ${index} of ${this.desiredPath.length} for ${wrappedTheta}`);\n    }\n    return this.desiredPath[index];\n  }\n\n  forward({ x, y, theta }) {\n    const { x: desiredX, y: desiredY } = this._getDesiredPoint(theta);\n    return {\n      error: sqrt((desiredX - x) ** 2 + (desiredY - y) ** 2)\n    };\n  }\n\n  backward({ x, y, theta }, { error }) {\n    const { x: desiredX, y: desiredY } = this._getDesiredPoint(theta);\n\n    // pasted from linkage_math_3.py output\n    const derror_dx = (-desiredX + x) / error;\n    const derror_dy = (-desiredY + y) / error;\n    // end paste\n\n    return {\n      x: { error: derror_dx },\n      y: { error: derror_dy },\n      theta: { error: 0 }\n    };\n  }\n}\n\nmodule.exports = { EllipseNode, ErrorPathNode };\n\n//# sourceURL=webpack:///./src/EllipseNodes.js?");

/***/ }),

/***/ "./src/EllipseRenderer.js":
/*!********************************!*\
  !*** ./src/EllipseRenderer.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n\n// $FlowFixMe\nconst optimjs = __webpack_require__(/*! optimization-js */ \"./node_modules/optimization-js/src/optimization.js\");\nconst { forward, backward } = __webpack_require__(/*! ./ComputationalGraph */ \"./src/ComputationalGraph.js\");\nconst { ErrorPathNode, EllipseNode } = __webpack_require__(/*! ./EllipseNodes */ \"./src/EllipseNodes.js\");\n\nfunction optimizeEllipse(start, goalPath, usePhase) {\n  const {\n    a: startA,\n    b: startB,\n    x0: startX0,\n    y0: startY0,\n    phase: startPhase\n  } = start;\n\n  const nodes = [new EllipseNode({ a: 'a', b: 'b', x0: 'x0', y0: 'y0', phase: 'phase', theta: 'theta' }, { x1: 'x1', y1: 'y1' }), new ErrorPathNode({ x: 'x1', y: 'y1', theta: 'theta' }, { error: 'error' }, goalPath)];\n\n  const result = optimjs.minimize_GradientDescent(([a, b, x0, y0, phase]) => {\n    const cache = new Map([['a', a], ['b', b], ['x0', x0], ['y0', y0], ['phase', phase], ['theta', 0]]);\n    let error = 0;\n    for (let i = 0; i < goalPath.length; i += 1) {\n      const fcache = new Map(cache).set('theta', i / goalPath.length * (Math.PI * 2));\n      forward(fcache, nodes);\n      error += fcache.get('error');\n    }\n    return error;\n  }, ([a, b, x0, y0, phase]) => {\n    const cache = new Map([['a', a], ['b', b], ['x0', x0], ['y0', y0], ['phase', phase], ['theta', 0]]);\n    let totalGradient = [0, 0, 0, 0, 0];\n    for (let i = 0; i < goalPath.length; i += 1) {\n      const fcache = new Map(cache).set('theta', i / goalPath.length * (Math.PI * 2));\n      const gradient = backward(fcache, nodes, 'error');\n      totalGradient[0] += gradient.get('a');\n      totalGradient[1] += gradient.get('b');\n      totalGradient[2] += gradient.get('x0');\n      totalGradient[3] += gradient.get('y0');\n      if (usePhase) {\n        totalGradient[4] += gradient.get('phase');\n      }\n    }\n    totalGradient = totalGradient.map(e => e / goalPath.length);\n    return totalGradient;\n  }, [startA, startB, startX0, startY0, startPhase]);\n\n  const finalEllipse = result.argument;\n\n  return {\n    a: finalEllipse[0],\n    b: finalEllipse[1],\n    x0: finalEllipse[2],\n    y0: finalEllipse[3],\n    phase: finalEllipse[4]\n  };\n}\n\nclass EllipseRenderer {\n\n  constructor(canvasID, usePhase) {\n    _initialiseProps.call(this);\n\n    const dataAreaID = `${canvasID}data`;\n    const dataArea = document.getElementById(dataAreaID);\n    if (!dataArea) {\n      throw new Error(`cannot find dataArea element: ${dataAreaID}`);\n    }\n    this.dataArea = dataArea;\n    const canvas = document.getElementById(canvasID);\n    const { width, height } = canvas;\n    const ctx = canvas.getContext('2d');\n    ctx.scale(width / 20, -height / 20);\n    ctx.translate(10, -10);\n    ctx.lineWidth = 0.1;\n\n    this.width = width;\n    this.height = height;\n    this.ctx = ctx;\n    this.path = [];\n    const phase = usePhase ? Math.PI / 3 : 0;\n    this.ellipse = {\n      a: 5,\n      b: 1,\n      x0: 0,\n      y0: 0,\n      phase\n    };\n    this.isDragging = false;\n    this.usePhase = usePhase;\n\n    canvas.onmousedown = this.onMouseDown;\n    canvas.onmousemove = this.onMouseMove;\n    canvas.onmouseup = this.onMouseUp;\n  }\n\n}\n\nvar _initialiseProps = function () {\n  this.onMouseDown = () => {\n    this.path = [];\n    this.isDragging = true;\n  };\n\n  this.onMouseMove = ({ offsetX, offsetY }) => {\n    if (!this.isDragging ||\n    /* border */\n    offsetX < 0 || offsetY < 0 || offsetX > this.width || offsetY > this.height) {\n      return;\n    }\n\n    const x = offsetX / this.width * 20 - 10;\n    const y = -offsetY / this.height * 20 + 10;\n\n    this.path.push({ x, y });\n    this.render();\n  };\n\n  this.onMouseUp = () => {\n    this.isDragging = false;\n    console.log('optimizing...');\n    this.ellipse = optimizeEllipse(this.ellipse, this.path, this.usePhase);\n    console.log('done optimizating!');\n    this.render();\n  };\n\n  this.render = () => {\n    const { ctx, ellipse, path } = this;\n\n    ctx.clearRect(-10, -10, 20, 20);\n\n    ctx.strokeStyle = 'black';\n    // draw grid\n    ctx.lineWidth = 0.04;\n\n    ctx.beginPath();\n    ctx.moveTo(0, -10);\n    ctx.lineTo(0, 10);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(-10, 0);\n    ctx.lineTo(10, 0);\n    ctx.stroke();\n\n    ctx.lineWidth = 0.01;\n\n    for (let x = -10; x <= 10; x += 1) {\n      ctx.beginPath();\n      ctx.moveTo(x, -10);\n      ctx.lineTo(x, 10);\n      ctx.stroke();\n    }\n    for (let y = -10; y <= 10; y += 1) {\n      ctx.beginPath();\n      ctx.moveTo(-10, y);\n      ctx.lineTo(10, y);\n      ctx.stroke();\n    }\n\n    // draw ellipse\n    const { a, b, x0, y0 } = ellipse;\n    ctx.beginPath();\n    this.ctx.ellipse(x0, y0, Math.abs(a), Math.abs(b), 0, 0, Math.PI * 2);\n    ctx.stroke();\n\n    // sample from theta=0 from the ellipse model\n    const node = new EllipseNode({ a: 'a', b: 'b', x0: 'x0', y0: 'y0', phase: 'phase', theta: 'theta' }, { x1: 'x1', y1: 'y1' });\n    const { x1, y1 } = node.forward({ ...ellipse, theta: 0 });\n    ctx.beginPath();\n    ctx.arc(x1, y1, 0.1, 0, 2 * Math.PI);\n    ctx.stroke();\n\n    // print model\n    this.dataArea.innerHTML = JSON.stringify(ellipse);\n\n    // draw path\n    if (path.length < 2) {\n      return;\n    }\n    ctx.strokeStyle = 'blue';\n    ctx.lineWidth = 0.01;\n    ctx.beginPath();\n    ctx.moveTo(path[0].x, path[0].y);\n    for (let i = 0; i < path.length; i += 1) {\n      ctx.lineTo(path[i].x, path[i].y);\n    }\n    ctx.stroke();\n  };\n};\n\nmodule.exports = EllipseRenderer;\n\n//# sourceURL=webpack:///./src/EllipseRenderer.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EllipseRenderer = __webpack_require__(/*! ./EllipseRenderer */ \"./src/EllipseRenderer.js\");\n\nnew EllipseRenderer('canvas0', true).render();\nnew EllipseRenderer('canvas1', false).render();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });